// RobotBuilder Version: 1.5BB
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc330.subsystems;

import org.usfirst.frc330.Robot;
import org.usfirst.frc330.RobotMap;
import org.usfirst.frc330.commands.*;
import org.usfirst.frc330.constants.MastPos;

import edu.wpi.first.wpilibj.*;

import org.usfirst.frc330.util.CSVLoggable;
import org.usfirst.frc330.wpilibj.DualSpeedController;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class Mast extends Subsystem {

	protected PIDController mastPID;

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	SpeedController mastRight = RobotMap.mastmastRight;
	SpeedController mastLeft = RobotMap.mastmastLeft;
	DualSpeedController mast = RobotMap.mastmast;
	AnalogInput mastPot = RobotMap.mastmastPot;
	DoubleSolenoid mastLock = RobotMap.mastmastLock;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
		setDefaultCommand(new HoldMast());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		//setDefaultCommand(new MySpecialCommand());
	}

	// Mast PIDController source and output objects
	public PIDOutput mastPIDOutput = new PIDOutput()  {
		public void pidWrite(double output) {
			setMast(output);	
		}
	};

	public PIDSource mastPIDSource = new PIDSource() {
		public double pidGet() {
			return getMastAngle();
		}
	};

	public Mast()
	{

		// Mast PIDController object
		mastPID = new PIDController (MastPos.proportional,
				MastPos.integral,
				MastPos.derivitive,mastPIDSource,mastPIDOutput);
		mastPID.setAbsoluteTolerance(MastPos.tolerance);

		// Add to Smart Dashboard
		SmartDashboard.putData("MastPID", mastPID);
		SmartDashboard.putBoolean("MastOverride", false);

		////////////
		// LOG IT!
		////////////
		CSVLoggable temp = new CSVLoggable() {
			public double get() { return mastLeft.get(); }
		};
		Robot.csvLogger.add("MastLeftOutput", temp);

		temp = new CSVLoggable() {
			public double get() { return mastRight.get(); }
		};
		Robot.csvLogger.add("MastRightOutput", temp);

		temp = new CSVLoggable() {
			public double get() { return getMastFrontLimit(); }
		};
		Robot.csvLogger.add("MastFrontLimit", temp);

		temp = new CSVLoggable() {
			public double get() { return getMastRearLimit(); }
		};
		Robot.csvLogger.add("MastRearLimit", temp);

		temp = new CSVLoggable() {
			public double get() { return getMastLock(); }
		};
		Robot.csvLogger.add("MastLockSolenoid", temp);

		temp = new CSVLoggable(true) {
			public double get() { return getMastAngle(); }
		};
		Robot.csvLogger.add("MastAngle", temp);

		temp = new CSVLoggable() {
			public double get() { return getMastPotAvgVoltage(); }
		};
		Robot.csvLogger.add("MastPotAvgVoltage", temp);

		temp = new CSVLoggable() {
			public double get() { return Robot.powerDP.getMastLeftCurrent(); }
		};
		Robot.csvLogger.add("MastLeftCurrent", temp);

		temp = new CSVLoggable() {
			public double get() { return Robot.powerDP.getMastRightCurrent(); }
		};
		Robot.csvLogger.add("MastRightCurrent", temp);
	}

	// Set Mast
	// TODO: Check the logic
	public void setMast(double output){
		if (output > 0 && getMastAngle() > MastPos.rearLimit) // Todo: Check this logic
		{
			mast.set(0);
		}
		else if (output < 0 && getMastAngle() < MastPos.frontLimit)// Todo: Check this logic
		{
			mast.set(0);
		}
		else if (output > 0 && Robot.powerDP.getMastLeftCurrent() < MastPos.currentLowerLimit)
		{
			mast.set(0);
		}
		else if (output < 0 && Robot.powerDP.getMastLeftCurrent() > MastPos.currentUpperLimit)
		{
			mast.set(0);
		}
		else if (output > 0 && Robot.powerDP.getMastRightCurrent() < MastPos.currentLowerLimit)
		{
			mast.set(0);
		}
		else if (output < 0 && Robot.powerDP.getMastRightCurrent() > MastPos.currentUpperLimit)
		{
			mast.set(0);
		}
		else
		{
			mast.set(output);
			//mastRight.set(-output); // Todo: check polarity and then re-enable
		}
	}

	public void setMastAngle(double position)
	{
		mastPID.setSetpoint(position);
	}

	public double getMastAngle()
	{
		double sensorRange = getMastRearLimit() - getMastFrontLimit();
		double angleRange  = MastPos.rearLimitAngle - MastPos.frontLimitAngle;

		return angleRange/sensorRange * (mastPot.getAverageVoltage() - getMastFrontLimit()) + MastPos.frontLimitAngle;
	}

	public void setMastFrontLimit()
	{        
		String name;

		if (Robot.isPracticeRobot())
			name = "PracticeMastFrontLimit";
		else
			name = "CompetitionMastFrontLimit";

		Preferences.getInstance().putDouble(name, mastPot.getAverageVoltage());
		Preferences.getInstance().save();
	}

	public double getMastFrontLimit() {
		String name;
		if (Robot.isPracticeRobot())
			name = "PracticeMastFrontLimit";
		else
			name = "CompetitionMastFrontLimit";
		return Preferences.getInstance().getDouble(name, MastPos.rearLimit);
	}

	public void setMastRearLimit()
	{
		String name;

		if (Robot.isPracticeRobot())
			name = "PracticeMastRearLimit";
		else
			name = "CompetitionMastRearLimit";

		Preferences.getInstance().putDouble(name, mastPot.getAverageVoltage());
		Preferences.getInstance().save();
	}

	public double getMastRearLimit() {
		String name;
		if (Robot.isPracticeRobot())
			name = "PracticeMastRearLimit";
		else
			name = "CompetitionMastRearLimit";
		return Preferences.getInstance().getDouble(name, MastPos.frontLimit);
	}

	public double getMastPotAvgVoltage() {
		return mastPot.getAverageVoltage();
	}

	public double getMastLock() {
		if(mastLock.get() == DoubleSolenoid.Value.kForward) 
		{
			return 1.0;
		} 
		else 
		{
			return 0.0;
		}
	}

	/////////////////////////////////////////////////////////////
	// PID Stuff
	/////////////////////////////////////////////////////////////
	public void setMastAbsoluteTolerance(double absvalue) {
		mastPID.setAbsoluteTolerance(absvalue);
	}
	public synchronized double getMastSetpoint() {
		return mastPID.getSetpoint();
	}

	// Method to check if Mast is on target
	public synchronized boolean onMastTarget() {
		return mastPID.onTarget();
	}

	// Method returns if Arm is enabled
	public synchronized boolean isMastEnable() {
		return mastPID.isEnable();
	}
	// Method to Enable Mast
	public synchronized void enableMast() {
		mastPID.enable();
	}
	// Method to Disable Arm
	public synchronized void disableMast() {
		mastPID.disable();
	}

	public void stopMast()
	{
		if (mastPID.isEnable())
		{
			mastPID.reset();
		}
	}
	
	public void softDriveForward()
	{
		mast.set(MastPos.softDrive);
	}
}


